from math import cos, tanh, exp, sin  # Импортируем субмодули математических значений
from random import uniform, random  # Импортируем субмодуль для генерирования случайных чисел

def SimulatedAnnealing(f, a, b):       # Метод имитации отжига

# Формирование нужной таблицы со столбцами:
# N - точка по счёту
# T - температура
# x - сама точка
# f(x) - значение функции в точке х
# P - вероятность перехода
# "Принята ли точка?" - в зависимости от результата работы "да" или "нет"

    print("+-----+------------+------------+------------+------------+------------+")
    print("|  N  |     T      |     x      |     f(x)   |     P      | Принята т.?|")
    print("+-----+------------+------------+------------+------------+------------+")

    max_T = 10000                       # Максимальная температура
    min_T = 0.01                        # Минимальная температура
    x = uniform(a, b)                   # Выбираем случайное число, которое будет начальным решением
    func_x = UnimodalFunction(x)        # Вычисляем значение функции в этой точке
    N = 1                               # Точка (итерация)
    it_T = max_T                        # Объявляем итерацонную температуру и присваиваем ей значение максимальной
    while it_T > min_T:                         # Запускаем цикл. Пока очередная температура больше минимальной...
        xNew = uniform(a, b)                    # Случайно выбираем точку
        func_xNew = UnimodalFunction(xNew)      # Вычисляем значение функции в этой точке
        delta_func = func_xNew - func_x         # Вычисляем дельта-функцию
        P = exp(-1*(delta_func) / it_T)         # Предварительно вычислим вероятность перехода
        if delta_func <= 0:
            x = xNew
            print('| %*d | %*.3f | %*.3f | %*.3f | %*s | %*s |' % (3, N, 10, it_T, 10, x, 10, f(x), 10, "1", 10, 'Да'))
        elif delta_func > 0:
            if (random() < P):
                x = xNew
                print('| %*d | %*.3f | %*.3f | %*.3f | %*.4f | %*s |' % (3, N, 10, it_T, 10, x, 10, f(x), 10, P, 10, 'Да'))
            else:
                print('| %*d | %*.3f | %*.3f | %*.3f | %*.4f | %*s |' % (3, N, 10, it_T, 10, x, 10, f(x), 10, P, 10, 'Нет'))
        N += 1
        it_T *= 0.95

      #  if func_xNew < func_x:
       #     x = xNew

    print("+-----+------------+------------+------------+------------+------------+")

    return x

# Заданная унимодальная функция
def UnimodalFunction(x):
	 return cos(x) * tanh(x)
def MultimodalFunction(x):
	 return UnimodalFunction(x) * sin(5*x)

# Интервал поиска [-2, 0]
a = -2
b = 0

# Вызов метода и печать минимума
xMin = SimulatedAnnealing(UnimodalFunction, a, b)
xMinM = SimulatedAnnealing(MultimodalFunction, a, b)
# print('Минимум унимодальной функции:', xMin)
print('Минимум мультимодальной функции:', xMinM)